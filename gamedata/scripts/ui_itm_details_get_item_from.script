--[[
	Get Item From Mod
	Shows which items can be disassembled to obtain the current item
	Adds "Receive from" section to item details UI
--]]


------------------------------------------------------------
-- Monkey-patch UICellContainer:GetSortMethod to add custom sort
------------------------------------------------------------
local original_GetSortMethod = utils_ui.UICellContainer.GetSortMethod

function utils_ui.UICellContainer:GetSortMethod()
	if self.sort_method == "by_index" then
		return function(t, a, b)
			return a < b  -- Sort by index to preserve array order
		end
	end
	return original_GetSortMethod(self)
end


------------------------------------------------------------
-- Reverse Lookup Function
------------------------------------------------------------
function get_items_that_produce(target_section)
	if not (target_section and itms_manager.ini_parts) then
		return {}, {}
	end

	local temp_results = {}
	local ini = itms_manager.ini_parts

	-- Get number of lines in [nor_parts_list] section
	local n = ini:line_count("nor_parts_list")

	-- Iterate through each line in the section
	for i=0, n-1 do
		local result_str, item_section, parts_str = ini:r_line_ex("nor_parts_list", i, "", "")

		if item_section and parts_str and parts_str ~= "" then
			-- Parse the comma-separated parts list
			local parts_list = str_explode(parts_str, ",")

			-- Count how many times target_section appears in this item's output
			local count = 0
			for j=1, #parts_list do
				if parts_list[j] == target_section then
					count = count + 1
				end
			end

			-- If found at least once, add to temporary results
			if count > 0 then
				temp_results[#temp_results + 1] = {
					item = item_section,
					count = count
				}
			end
		end
	end

	-- Sort by count in descending order (highest count first)
	table.sort(temp_results, function(a, b)
		return a.count > b.count
	end)

	-- Create result arrays: items indexed by position, counts indexed by section name
	local result_items = {}
	local result_counts = {}
	for i=1, #temp_results do
		result_items[i] = temp_results[i].item
		result_counts[temp_results[i].item] = temp_results[i].count  -- Index by section name!
	end

	return result_items, result_counts
end


------------------------------------------------------------
-- Monkey-Patch UIItemSheet:Reset
------------------------------------------------------------
-- Store original Reset function
local original_reset = ui_itm_details.UIItemSheet.Reset

-- Override with extended version
function ui_itm_details.UIItemSheet:Reset(obj)
	-- Call original function first
	original_reset(self, obj)

	-- Get item section
	local sec = ini_sys:r_string_ex(obj:section(),"parent_section") or obj:section()

	-- Find items that disassemble into this item
	local source_items, source_counts = ui_itm_details_get_item_from.get_items_that_produce(sec)

	if source_items and (#source_items > 0) then
		local xml = self.xml

		-- Add section header
		self:AddText(xml, "text_b_l", 0, game.translate_string("ui_get_item_from"))

		-- Add container with source items
		self.CC["get_from"] = self:AddContainer(xml, "cont", 0, source_items)

		-- Set custom sort method and re-init to apply our sort order
		self.CC["get_from"].sort_method = "by_index"
		self.CC["get_from"]:Reinit(source_items)

		-- Manually set the count info for each cell (indexed by section name)
		for idx, ci in pairs(self.CC["get_from"].cell) do
			if ci:IsShown() and ci.section then
				local count = source_counts[ci.section]
				if count then
					ci.flags.info = count

					-- Initialize counter element if it doesn't exist
					if (not ci.cnt) then
						ci.cnt = xml:InitStatic("itm_details:form:cont:cell:cnt", ci.cell)
					end

					-- Set counter text and show it
					ci.cnt:TextControl():SetText("x" .. tostring(count))
					ci.cnt:Show(true)
				end
			end
		end

		-- Add separator line
		self:AddLine(xml, 0)
	end
end
